var documenterSearchIndex = {"docs":
[{"location":"api.html#SpinGlassExhaustive","page":"API Reference","title":"SpinGlassExhaustive","text":"","category":"section"},{"location":"api.html#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [SpinGlassExhaustive]","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [SpinGlassExhaustive]\nOrder   = [:function, :type]\n","category":"page"},{"location":"api.html#SpinGlassExhaustive.energy-Tuple{Any, Any}","page":"API Reference","title":"SpinGlassExhaustive.energy","text":"energy(state_code, graph)\n\n\nstate_code: state code for which the energy.\ngraph: graph of the ising model.\n\nReturns the state energy.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.energy_qubo-Tuple{Any, Any}","page":"API Reference","title":"SpinGlassExhaustive.energy_qubo","text":"energy_qubo(state_code, graph)\n\n\nstate_code: state code for which the energy expressed in qubo is to be calculated.\ngraph: graph of the ising model.\n\nReturns the state energy expressed as QUBO.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.exhaustive_search-Tuple{LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, Float64}, Int64}}","page":"API Reference","title":"SpinGlassExhaustive.exhaustive_search","text":"exhaustive_search(ig)\n\n\nig::IsingGraph: graph of ising model represented by IsingGraph structure.\n\nReturns energies and states for provided graph by brute-forece alorithm based on GPU.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.exhaustive_search_bucket","page":"API Reference","title":"SpinGlassExhaustive.exhaustive_search_bucket","text":"exhaustive_search_bucket(ig)\nexhaustive_search_bucket(ig, how_many)\n\n\nig::IsingGraph: graph of ising model represented by IsingGraph structure.\n\nReturns energies and states for provided graph by brute-forece alorithm supported by bucket selection based on GPU.\n\n\n\n\n\n","category":"function"},{"location":"api.html#SpinGlassExhaustive.generate_random_graph-Tuple{Int64}","page":"API Reference","title":"SpinGlassExhaustive.generate_random_graph","text":"generate_random_graph(d)\n\n\nd::Int: size of random graph.\n\nReturns random array of size d.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.get_energy_offset-Tuple{Any}","page":"API Reference","title":"SpinGlassExhaustive.get_energy_offset","text":"get_energy_offset(graph)\n\n\ngraph: graph of the ising model.\n\nReturns offest between Ising model graph and its QUBO representation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.graph_to_dict-Tuple{Any}","page":"API Reference","title":"SpinGlassExhaustive.graph_to_dict","text":"graph_to_dict(graph)\n\n\ngraph: graph of the ising model.\n\nConverts Ising model graph to Dict.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.graph_to_qubo-Tuple{Any}","page":"API Reference","title":"SpinGlassExhaustive.graph_to_qubo","text":"graph_to_qubo(graph)\n\n\ngraph: graph of the ising model.\n\nConverts Ising model graph to QUBO representation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.kernel-Tuple{Any, Any}","page":"API Reference","title":"SpinGlassExhaustive.kernel","text":"kernel(graph, energies)\n\n\ngraph: graph of the ising model.\nenergies: array filled with zeros. Each array index represents the state of the system.\n\nReturns energies for every state.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.kernel_bucket-Tuple{Any, Any, Any}","page":"API Reference","title":"SpinGlassExhaustive.kernel_bucket","text":"kernel_bucket(graph, energies, idx)\n\n\ngraph: graph of the ising model.\nenergies: array filled with zeros. Each array index represents the state of the system.\nidx: list for collecting partial energy results.\n\nReturns energies for given indexes.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.kernel_part-NTuple{4, Any}","page":"API Reference","title":"SpinGlassExhaustive.kernel_part","text":"kernel_part(graph, energies, part_lst, part_st)\n\n\ngraph: graph of the ising model.\nenergies: array filled with zeros. Each array index represents the state of the system.\npart_lst: list for collecting partial energy results.\npart_st: list for collecting partial state results.\n\nReturns energies for every state.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.kernel_qubo-Tuple{Any, Any}","page":"API Reference","title":"SpinGlassExhaustive.kernel_qubo","text":"kernel_qubo(graph, energies)\n\n\ngraph: graph of the ising model.\nenergies: array filled with zeros. Each array index represents the state of the system.\n\nReturns energies energy expressed as QUBO for every state.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.max_chunk_size-Tuple{}","page":"API Reference","title":"SpinGlassExhaustive.max_chunk_size","text":"max_chunk_size()\n\n\nReturns the maximum chunk size for the algorithm supported by bucket selection.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinGlassExhaustive.partial_exhaustive_search-Tuple{LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, Float64}, Int64}}","page":"API Reference","title":"SpinGlassExhaustive.partial_exhaustive_search","text":"partial_exhaustive_search(ig)\n\n\nig::IsingGraph: graph of ising model represented by IsingGraph structure.\n\nReturns energies and states for provided graph by brute-forece alorithm supported by partial selection based on GPU.\n\n\n\n\n\n","category":"method"},{"location":"lib/content/naive.html#naive.jl","page":"naive.jl","title":"naive.jl","text":"","category":"section"},{"location":"lib/content/naive.html","page":"naive.jl","title":"naive.jl","text":"function naiveenergykernel(J, energies, σ)","category":"page"},{"location":"lib/content/naive.html","page":"naive.jl","title":"naive.jl","text":"- J: partial description of graph of the ising model.\n- energies: array filled with zeros. Each array index represents the state of the system.\n- σ: partial description of graph of the ising model.\nReturns the state energy.","category":"page"},{"location":"lib/content/naive.html","page":"naive.jl","title":"naive.jl","text":"** function brute_force(ig::IsingGraph)**","category":"page"},{"location":"lib/content/naive.html","page":"naive.jl","title":"naive.jl","text":"- ig::IsingGraph: graph of ising model represented by IsingGraph structure.\nReturns energies and states for provided model by naive brute-forece alorithm based on GPU.","category":"page"},{"location":"man/details.html","page":"How to use GPU kernels for exaustive search","title":"How to use GPU kernels for exaustive search","text":"using SpinGlassExhaustive\n\nimport Pkg;\nPkg.add(\"CUDA\")\nusing CUDA\n\nPkg.add(\"SpinGlassEngine\")\nusing SpinGlassEngine\n\nPkg.add(\"SpinGlassNetworks\")\nusing SpinGlassNetworks","category":"page"},{"location":"man/details.html#How-to-use-GPU-kernels-for-exaustive-search","page":"How to use GPU kernels for exaustive search","title":"How to use GPU kernels for exaustive search","text":"","category":"section"},{"location":"man/details.html","page":"How to use GPU kernels for exaustive search","title":"How to use GPU kernels for exaustive search","text":"The section contains examples illustrating how to use CUDA kernels for exhaustive search of the solution space of the Ising model.","category":"page"},{"location":"man/details.html","page":"How to use GPU kernels for exaustive search","title":"How to use GPU kernels for exaustive search","text":"kernel_qubo - returns energies expressed as QUBO for every state","category":"page"},{"location":"man/details.html","page":"How to use GPU kernels for exaustive search","title":"How to use GPU kernels for exaustive search","text":"N = 8\ngraph = SpinGlassExhaustive.generate_random_graph(N)\nqubo = SpinGlassExhaustive.graph_to_qubo(graph)\n\ncu_qubo = qubo |> cu;\n\nk = 2\n\nenergies = CUDA.zeros(2^N);\n\nthreadsPerBlock = 2^k\nblocksPerGrid = 2^(N-k)\n\n@cuda blocks=(blocksPerGrid) threads=(threadsPerBlock) SpinGlassExhaustive.kernel_qubo(cu_qubo, energies);\n\nstates = sortperm(energies);\nenergies[states];\n\noffset = SpinGlassExhaustive.get_energy_offset(Array(graph));\nArray(sort!(energies)).-offset","category":"page"},{"location":"man/details.html","page":"How to use GPU kernels for exaustive search","title":"How to use GPU kernels for exaustive search","text":"kernel - returns energies for every state","category":"page"},{"location":"man/details.html","page":"How to use GPU kernels for exaustive search","title":"How to use GPU kernels for exaustive search","text":"N = 8\ngraph = SpinGlassExhaustive.generate_random_graph(N)\ncu_graph = graph |> cu;\n\nk = 2\n\nenergies = CUDA.zeros(2^N);\n\nthreadsPerBlock = 2^k\nblocksPerGrid = 2^(N-k)\n\n@cuda blocks=(blocksPerGrid) threads=(threadsPerBlock) SpinGlassExhaustive.kernel(cu_graph, energies);\n\nstates = sortperm(energies);\nenergies[states]","category":"page"},{"location":"man/details.html","page":"How to use GPU kernels for exaustive search","title":"How to use GPU kernels for exaustive search","text":"kernel_part - returns the lowest energies for 2^(N-k) states","category":"page"},{"location":"man/details.html","page":"How to use GPU kernels for exaustive search","title":"How to use GPU kernels for exaustive search","text":"N = 8\ngraph = SpinGlassExhaustive.generate_random_graph(N)\ncu_graph = graph |> cu;\n\nk = 2\n\nenergies = CUDA.zeros(2^N);\npart_st = CUDA.zeros(2^(N-k));\npart_lst = CUDA.zeros(2^(N-k));\n\nthreadsPerBlock = 2^k\nblocksPerGrid = 2^(N-k)\n\n@cuda blocks=(blocksPerGrid) threads=(threadsPerBlock) SpinGlassExhaustive.kernel_part(cu_graph, energies, part_lst, part_st);\n\nidx = sortperm(part_lst);\nstates = part_st[idx];\npart_lst[idx]","category":"page"},{"location":"man/details.html","page":"How to use GPU kernels for exaustive search","title":"How to use GPU kernels for exaustive search","text":"kernel_bucket - returns energies for given indexes","category":"page"},{"location":"man/details.html","page":"How to use GPU kernels for exaustive search","title":"How to use GPU kernels for exaustive search","text":"N = 8\nhow_many = 4\n\ngraph = SpinGlassExhaustive.generate_random_graph(N)\n\nig = SpinGlassEngine.ising_graph(SpinGlassExhaustive.graph_to_dict(graph))\n\nL = SpinGlassNetworks.nv(ig)    \n\nσ = CUDA.fill(Int32(-1), L, 2^L);\nJ = couplings(ig) + SpinGlassNetworks.Diagonal(biases(ig))\nJ_dev = CUDA.CuArray(J)\n\nN = size(J_dev,1)\n\nchunk_size = SpinGlassExhaustive.max_chunk_size()\n\nif chunk_size > N\n    chunk_size = N\nend\n\n\nenergies_d = CUDA.zeros(Float64, 2^chunk_size);\nlowest_d = CUDA.zeros(Float64, how_many*2);\nlowest_states_d = CUDA.zeros(Int64, how_many*2);\n\nk = 2\nthreadsPerBlock = 2^k\nblocksPerGrid = 2^(chunk_size-k)\n\n\n\nfor i in 1:2^(N-chunk_size)\n\n    idx = (i-1)*(2^chunk_size) + 1 \n    \n    @cuda blocks=(blocksPerGrid) threads=(threadsPerBlock) SpinGlassExhaustive.kernel_bucket(J_dev, energies_d, idx)\n\n    states_d = sortperm(energies_d)[1:how_many]\n\n    if i == 1\n        lowest_d[1:how_many] = energies_d[states_d]\n        lowest_states_d[1:how_many] = (states_d.+idx)\n    else\n        lowest_d[how_many+1:2*how_many] = energies_d[states_d]\n        lowest_states_d[how_many+1:2*how_many] = (states_d.+idx)\n\n        states = sortperm(lowest_d)\n        lowest_d = lowest_d[states]\n        lowest_states_d = lowest_states_d[states]\n    end \nend\n\nlowest_d[1:how_many], lowest_states_d[1:how_many]","category":"page"},{"location":"man/integration.html","page":"Integration SpinGlassExhaustive with other EuroHPC packages","title":"Integration SpinGlassExhaustive with other EuroHPC packages","text":"using SpinGlassExhaustive\n\nimport Pkg;\nPkg.add(\"CUDA\")\nusing CUDA\n\nPkg.add(\"SpinGlassEngine\")\nusing SpinGlassEngine","category":"page"},{"location":"man/integration.html#Integration-SpinGlassExhaustive-with-other-EuroHPC-packages","page":"Integration SpinGlassExhaustive with other EuroHPC packages","title":"Integration SpinGlassExhaustive with other EuroHPC packages","text":"","category":"section"},{"location":"man/integration.html","page":"Integration SpinGlassExhaustive with other EuroHPC packages","title":"Integration SpinGlassExhaustive with other EuroHPC packages","text":"As part of the Euro-HPC project, a number of tools were developed to solve the Ising problem. In this section, we will present how to benchmark algorithms from SpinGlassExhaustive, SpinGlassEngine.jl and SpinGlassNetworks.jl.","category":"page"},{"location":"man/integration.html","page":"Integration SpinGlassExhaustive with other EuroHPC packages","title":"Integration SpinGlassExhaustive with other EuroHPC packages","text":"instance = \"benchmarks/pathological/test_3_4_3.txt\"\n\nbench(instance)","category":"page"},{"location":"man/how_use.html","page":"How use SpinGlassExhaustive","title":"How use SpinGlassExhaustive","text":"using SpinGlassExhaustive\n\nimport Pkg;\nPkg.add(\"CUDA\")\nusing CUDA\n\nPkg.add(\"SpinGlassEngine\")\nusing SpinGlassEngine","category":"page"},{"location":"man/how_use.html#How-use-SpinGlassExhaustive","page":"How use SpinGlassExhaustive","title":"How use SpinGlassExhaustive","text":"","category":"section"},{"location":"man/how_use.html","page":"How use SpinGlassExhaustive","title":"How use SpinGlassExhaustive","text":"Within the package, you can use one of the following functions to exhaustive search of the solution space of the Ising model","category":"page"},{"location":"man/how_use.html","page":"How use SpinGlassExhaustive","title":"How use SpinGlassExhaustive","text":"brute_force - it provides solution based on CPU brute force searching;\nexhaustive_search - it provides solution based on GPU brute force searching;\nexhaustive_search_bucket - it provides solution based on GPU brute force searching supported by bucket-sort algorithm;\npartial_exhaustive_search - it provides partial solution based on GPU brute force searching;","category":"page"},{"location":"man/how_use.html","page":"How use SpinGlassExhaustive","title":"How use SpinGlassExhaustive","text":"Each of these functions is called with ising_graph object as input.","category":"page"},{"location":"man/how_use.html","page":"How use SpinGlassExhaustive","title":"How use SpinGlassExhaustive","text":"Below is an example of using the above functions for a random graph generated with the function generate_random_graph.","category":"page"},{"location":"man/how_use.html","page":"How use SpinGlassExhaustive","title":"How use SpinGlassExhaustive","text":"N = 8\n\ngraph = SpinGlassExhaustive.generate_random_graph(N)\n\ncu_graph = graph |> cu;\n\nig = SpinGlassEngine.ising_graph(SpinGlassExhaustive.graph_to_dict(graph))\n\nSpinGlassEngine.brute_force(ig)\n\nSpinGlassExhaustive.exhaustive_search(ig)\n\nSpinGlassExhaustive.exhaustive_search_bucket(ig)\n\nSpinGlassExhaustive.partial_exhaustive_search(ig)","category":"page"},{"location":"lib/SpinGlassExhaustive.html#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"lib/SpinGlassExhaustive.html#Index","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"lib/SpinGlassExhaustive.html","page":"Documentation","title":"Documentation","text":"A list of all documentation sorted by module.","category":"page"},{"location":"lib/SpinGlassExhaustive.html","page":"Documentation","title":"Documentation","text":"Modules = [SpinGlassExhaustive]","category":"page"},{"location":"lib/SpinGlassExhaustive.html","page":"Documentation","title":"Documentation","text":"Modules = [SpinGlassExhaustive]","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Author = \"Dariusz Kurzyk, Łukasz Pawela\"","category":"page"},{"location":"index.html#Home","page":"Introduction","title":"Home","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A julia package providing algorithm for solving the problem of finding the ground state of a spin glass system based on exhaustive search by GPU. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The package includes algorithms:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"naive brute-force exhaustive search by GPU\nbrute-force exhaustive search with bucket selection by GPU\nbrute-force exhaustive search returning partial results by one kernel in GPU","category":"page"},{"location":"index.html#refs","page":"Introduction","title":"References","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[1] Jałowiecki, K., Rams, M. M., & Gardas, B. (2021). Brute-forcing spin-glass problems with CUDA. Computer Physics Communications, 260, 107728.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[2] Tao, M., Nakano, K., Ito, Y., Yasudo, R., Tatekawa, M., Katsuki, R., ... & Inaba, Y. (2020, May). A Work-Time Optimal Parallel Exhaustive Search Algorithm for the QUBO and the Ising model, with GPU implementation. In 2020 IEEE International Parallel and Distributed Processing Symposium Workshops (IPDPSW) (pp. 557-566). IEEE.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[3] Cook, C., Zhao, H., Sato, T., Hiromoto, M., & Tan, S. X. D. (2018). GPU based parallel Ising computing for combinatorial optimization problems in VLSI physical design. arXiv preprint arXiv:1807.10750.","category":"page"},{"location":"lib/content/ising.html#ising.jl","page":"ising.jl","title":"ising.jl","text":"","category":"section"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"function energy(state_code, graph)","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"- state_code: state code for which the energyis to be calculated.\n- graph: graph of the ising model.\nReturns the state energy.","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"function energyqubo(statecode, graph)","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"- state_code: state code for which the energy expressed in qubo is to be calculated.\n- graph: graph of the ising model.\nReturns the state energy expressed as QUBO.","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"function kernel(graph, energies)","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"- graph: graph of the ising model.\n- energies: array filled with zeros. Each array index represents the state of the system.\nReturns energies for every state.","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"function kernel_qubo(graph, energies)","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"- graph: graph of the ising model.\n- energies: array filled with zeros. Each array index represents the state of the system.\nReturns energies expressed as QUBO for every state.","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"function kernelpart(graph, energies, partlst, part_st)","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"- graph: graph of the ising model.\n- energies: array filled with zeros. Each array index represents the state of the system.\n- part_lst: list for collecting partial energy results\n- part_st: list for collecting partial state results\nReturns energies for every state.","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"function kernel_bucket(graph, energies, idx)","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"- graph: graph of the ising model.\n- energies: array filled with zeros. Each array index represents the state of the system.\n- idx: list for collecting partial energy results\nReturns energies for given indexes.","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"function exhaustive_search(ig::IsingGraph)","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"- ig::IsingGraph: graph of ising model represented by IsingGraph structure.\nReturns energies and states for provided model by brute-forece alorithm based on GPU.","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"function partialexhaustivesearch(ig::IsingGraph)","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"- ig::IsingGraph: graph of ising model represented by IsingGraph structure.\nReturns partial results for energies and states for provided model by brute-force algorithm based on GPU.","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"function exhaustivesearchbucket(ig::IsingGraph, how_many = 8)","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"- ig::IsingGraph: graph of ising model represented by IsingGraph structure.\n- how_many: number of states.\nReturns energies and states for provided model by brute-forece alorithm supported by bucket selection based on GPU.","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"function maxchunksize()","category":"page"},{"location":"lib/content/ising.html","page":"ising.jl","title":"ising.jl","text":"Returns the maximum chunk size for the algorithm supported by bucket selection.","category":"page"},{"location":"man/quickstart.html#manual","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"man/quickstart.html","page":"Quickstart","title":"Quickstart","text":"If this is your first use of the Julia Language, please read the Documentation. The latest release of SpinGlassExhaustive.jl can be installed from the Julia REPL prompt with","category":"page"},{"location":"man/quickstart.html","page":"Quickstart","title":"Quickstart","text":"julia> Pkg.add(\"SpinGlassExhaustive.jl\")","category":"page"},{"location":"man/quickstart.html","page":"Quickstart","title":"Quickstart","text":"Package SpinGlassExhaustive.jl can be loaded via","category":"page"},{"location":"man/quickstart.html","page":"Quickstart","title":"Quickstart","text":"julia> using SpinGlassExhaustive.jl","category":"page"},{"location":"man/quickstart.html#How-integrate-SpinGlassExhaustive-with-other-Euro-HPC-packages","page":"Quickstart","title":"How integrate SpinGlassExhaustive with other Euro-HPC packages","text":"","category":"section"},{"location":"man/quickstart.html","page":"Quickstart","title":"Quickstart","text":"As part of the Euro-HPC project, a number of tools were developed to solve the Ising problem. In this section, we will present how to benchmark algorithms from SpinGlassExhaustive, SpinGlassEngine.jl and SpinGlassNetworks.jl.","category":"page"}]
}
